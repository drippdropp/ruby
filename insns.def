/* -*- mode:c; style:ruby; coding: utf-8; indent-tabs-mode: nil -*- */

/* insns.def - YARV instruction definitions
 *
 * Copyright (C) 2004-2007 Koichi Sasada */

/* This file is a part of  the programming language Ruby.  Permission is hereby
 * granted, to either  redistribute and/or modify this file,  provided that the
 * conditions mentioned  in the  file COPYING  are met.   Consult the  file for
 * details. */

/* massive reformat by @shyouhei, to support per-insn attributes. */

/* structure
 * ---------
 *
 *  insn
 *  insn_name(ope)(pop)(ret)
 *      type decl, decl, ...;
 *  {
 *      attr type attr_name = { stmt; ... };
 *      attr type another_attr = { ... };
 *
 *      impl {
 *          arbitrary C code goes here...
 *      }
 *  }
 *
 * where
 *
 * insn_name: Name of the instruction e.g. "nop"
 * ope: Operands. Resides inside of ISeq.
 * pop: Values to pop from stack, "..." denotes variadic instruction.
 * ret: Values to push to stack, "..." also possible.
 * type decl: C variable declarations of ope/pop/ret.
 * attr_name: Name of an attribute e.g. "sp_inc"
 *
 * some notes
 * ----------
 *
 * - The "insn", "attr", and "impl" are keywords.
 *
 * - This syntax  is aimed  to be properly  colored by a  modern C  source code
 *   editor of your choice but not guaranteed.
 *
 * - Following  things  are  verbatimly  copied into  the  generated  C  source
 *   code. You must not define any evil macros that doesn't match curly braces.
 *
 *   - Those K&R-ish variable declarations
 *   - The { ... } part of every attributes.
 *   - The { ... } part right after keyword impl.
 *
 * - Attributes can see the operands.  But not stack variables.
 *
 * - Attributes  are generated  as  each  separate possibly-inlined  functions.
 *   Thus it makes no sense to have an attribute that does not return.
 *
 * - On the other hand  the instruction body is not a function.   It is a wrong
 *   idea to return from an instruction.  Doing so must result in a [BUG].
 *
 * attributes
 * ----------
 *
 * Any attributes can be attached  to any instructions but currently, following
 * attributes are recognized:
 *
 * sp_inc: By  defining this attribute  you can override stack  pointer growth.
 *         This  attribute  is  not  mandatory.   If  absent  stack  growth  is
 *         calculated from the instruction's push/pop count.
 *
 * purity: Tells if the instruction has  no side effect than given ope/pop/ret.
 *         Used for optimizations.  This is false if absent.
 *
 */

/* nop */
insn
nop()()()
{
    impl { /* none */ }
}

/**********************************************************/
/* deal with variables                                    */
/**********************************************************/

/* Get local variable (pointed by `idx' and `level').
 *   'level' indicates the nesting depth from the current block. */
insn
getlocal(idx, level)()(val)
    lindex_t idx;
    rb_num_t level;
    VALUE val;
{
    impl {
        int i, lev = (int)level;
        const VALUE *ep = GET_EP();

        /* optimized insns generated for level == (0|1) in
         * defs/opt_operand.def */
        for (i = 0; i < lev; i++) {
            ep = GET_PREV_EP(ep);
        }
        val = *(ep - idx);
    }
}

/* Set a local variable (pointed to by 'idx') as val.
 *   'level' indicates the nesting depth from the current block. */
insn
setlocal(idx, level)(val)()
    lindex_t idx;
    rb_num_t level;
    VALUE val;
{
    impl {
        int i, lev = (int)level;
        const VALUE *ep = GET_EP();

        /* optimized insns generated for level == (0|1) in
         * defs/opt_operand.def */
        for (i = 0; i < lev; i++) {
            ep = GET_PREV_EP(ep);
        }
        vm_env_write(ep, -(int)idx, val);
    }
}

/* Get value of special local variable ($~, $_, ..). */
insn
getspecial(key, type)()(val)
    rb_num_t key, type;
    VALUE val;
{
    impl { val = vm_getspecial(th, GET_LEP(), key, type); }
}

/* Set value of special local variable ($~, $_, ...) to obj. */
insn
setspecial(key)(obj)()
    rb_num_t key;
    VALUE obj;
{
    impl { lep_svar_set(th, GET_LEP(), key, obj); }
}

/* Get value of instance variable id of self.
 *   If is_local is not 0, get value of class local variable. */
insn
getinstancevariable(id, ic)()(val)
    ID id;
    IC ic;
    VALUE val;
{
    impl { val = vm_getinstancevariable(GET_SELF(), id, ic); }
}

/* Set value of instance variable id of self to val.
 *   If is_local is not 0, set value of class local variable. */
insn
setinstancevariable(id, ic)(val)()
    ID id;
    IC ic;
    VALUE val;
{
    impl { vm_setinstancevariable(GET_SELF(), id, val, ic); }
}

/* Get value of class variable id of klass as val. */
insn
getclassvariable(id)()(val)
    ID id;
    VALUE val;
{
    impl {
        val = rb_cvar_get(vm_get_cvar_base(rb_vm_get_cref(GET_EP()), GET_CFP()), id);
    }
}

/* Set value of class variable id of klass as val. */
insn
setclassvariable(id)(val)()
    ID id;
    VALUE val;
{
    impl {
        vm_ensure_not_refinement_module(GET_SELF());
        rb_cvar_set(vm_get_cvar_base(rb_vm_get_cref(GET_EP()), GET_CFP()), id, val);
    }
}

/*
 * Get constant variable id. If klass is Qnil, constants
 * are searched in the current scope. If klass is Qfalse, constants
 * are searched as top level constants. Otherwise, get constant under klass
 * class or module. */
insn
getconstant(id)(klass)(val)
    ID id;
    VALUE klass, val;
{
    impl {
        val = vm_get_ev_const(th, klass, id, 0);
    }
}

/*
 * Set constant variable id. If klass is Qfalse, constant
 * is able to access in this scope. if klass is Qnil, set
 * top level constant. otherwise, set constant under klass
 * class or module.
 */
insn
setconstant(id)(val, cbase)()
    ID id;
    VALUE val, cbase;
{
    impl {
        vm_check_if_namespace(cbase);
        vm_ensure_not_refinement_module(GET_SELF());
        rb_const_set(cbase, id, val);
    }
}

/* get global variable id. */
insn
getglobal(entry)()(val)
    GENTRY entry;
    VALUE val;
{
    impl { val = GET_GLOBAL((VALUE)entry); }
}

/* set global variable id as val. */
insn
setglobal(entry)(val)()
    GENTRY entry;
    VALUE val;
{
    impl { SET_GLOBAL((VALUE)entry, val); }
}

/**********************************************************/
/* deal with values                                       */
/**********************************************************/

/* put nil to stack. */
insn
putnil()()(val)
    VALUE val;
{
    impl { val = Qnil; }
}

/* put self. */
insn
putself()()(val)
    VALUE val;
{
    impl { val = GET_SELF(); }
}

/* put some object.
 *   i.e. Fixnum, true, false, nil, and so on. */
insn
putobject(val)()(val)
    VALUE val;
{
    impl { /* */ }
}

/* put special object.  "value_type" is for expansion. */
insn
putspecialobject(value_type)()(val)
    rb_num_t value_type;
    VALUE val;
{
    impl {
        enum vm_special_object_type type = (enum vm_special_object_type)value_type;

        switch (type) {
          case VM_SPECIAL_OBJECT_VMCORE:
            val = rb_mRubyVMFrozenCore;
            break;
          case VM_SPECIAL_OBJECT_CBASE:
            val = vm_get_cbase(GET_EP());
            break;
          case VM_SPECIAL_OBJECT_CONST_BASE:
            val = vm_get_const_base(GET_EP());
            break;
          default:
            rb_bug("putspecialobject insn: unknown value_type %d", type);
        }
    }
}

/* put iseq value. */
insn
putiseq(iseq)()(ret)
    ISEQ iseq;
    VALUE ret;
{
    impl { ret = (VALUE)iseq; }
}

/* put string val. string will be copied. */
insn
putstring(str)()(val)
    VALUE str, val;
{
    impl { val = rb_str_resurrect(str); }
}

/* put concatenate strings */
insn
concatstrings(num)(...)(val)
    rb_num_t num;
    VALUE val;
{
    attr rb_num_t sp_inc = { return 1 - num; };

    impl { val = rb_str_concat_literals(num, &TOPN(num-1)); }
}

/* push the result of to_str. */
insn
tostring()(val)(val)
    VALUE val;
{
    impl { val = rb_obj_as_string(val); }
}

/* Freeze (dynamically) created strings. if debug_info is given, set it. */
insn
freezestring(debug_info)(str)(str)
    VALUE debug_info, str;
{
    impl {
        if (!NIL_P(debug_info)) {
            rb_ivar_set(str, id_debug_created_info, debug_info);
        }
        rb_str_freeze(str);
    }
}

/* compile str to Regexp and push it.
 *   opt is the option for the Regexp. */
insn
toregexp(opt, cnt)(...)(val)
    rb_num_t opt, cnt;
    VALUE val;
{
    attr rb_num_t sp_inc = { return 1 - cnt; };

    impl {
        VALUE rb_reg_new_ary(VALUE ary, int options);
        const VALUE ary = \
            rb_ary_tmp_new_from_values(0, cnt, STACK_ADDR_FROM_TOP(cnt));
        val = rb_reg_new_ary(ary, (int)opt);
        rb_ary_clear(ary);
    }
}

/* put new array initialized with num values on the stack. */
insn
newarray(num)(...)(val)
    rb_num_t num;
    VALUE val;
{
    attr rb_num_t sp_inc = { return 1 - num; };

    impl { val = rb_ary_new4((long)num, STACK_ADDR_FROM_TOP(num)); }
}

/* dup array */
insn
duparray(ary)()(val)
    VALUE ary, val;
{
    impl { val = rb_ary_resurrect(ary); }
}

/* if TOS is an array expand, expand it to num objects.
 *   if the number of the array is less than num, push nils to fill.
 *   if it is greater than num, exceeding elements are dropped.
 *   unless TOS is an array, push num - 1 nils.
 *   if flags is non-zero, push the array of the rest elements.
 *   flag: 0x01 - rest args array
 *   flag: 0x02 - for postarg
 *   flag: 0x04 - reverse? */
insn
expandarray(num, flag)(..., ary)(...)
    rb_num_t num, flag;
    VALUE ary;
{
    attr rb_num_t sp_inc = { return num - 1 + (flag & 1 ? 1 : 0); };

    impl { vm_expandarray(GET_CFP(), ary, num, (int)flag); }
}

/* concat two arrays */
insn
concatarray()(ary1, ary2st)(ary)
    VALUE ary1, ary2st, ary;
{
    impl {
        const VALUE ary2 = ary2st;
        VALUE tmp1 = rb_check_convert_type(ary1, T_ARRAY, "Array", "to_a");
        VALUE tmp2 = rb_check_convert_type(ary2, T_ARRAY, "Array", "to_a");

        if (NIL_P(tmp1)) {
            tmp1 = rb_ary_new3(1, ary1);
        }

        if (NIL_P(tmp2)) {
            tmp2 = rb_ary_new3(1, ary2);
        }

        if (tmp1 == ary1) {
            tmp1 = rb_ary_dup(ary1);
        }
        ary = rb_ary_concat(tmp1, tmp2);
    }
}

/* call to_a on array ary to splat */
insn
splatarray(flag)(ary)(obj)
    VALUE flag, ary, obj;
{
    impl {
        VALUE tmp = rb_check_convert_type(ary, T_ARRAY, "Array", "to_a");
        if (NIL_P(tmp)) {
            tmp = rb_ary_new3(1, ary);
        }
        else if (RTEST(flag)) {
            tmp = rb_ary_dup(tmp);
        }
        obj = tmp;
    }
}

/* put new Hash from n elements. n must be an even number. */
insn
newhash(num)(...)(val)
    rb_num_t num;
    VALUE val;
{
    attr rb_num_t sp_inc = { return 1 - num; };

    impl {
        rb_num_t i;

        RUBY_DTRACE_CREATE_HOOK(HASH, num);

        val = rb_hash_new();

        for (i = num; i > 0; i -= 2) {
            const VALUE v = TOPN(i - 2);
            const VALUE k = TOPN(i - 1);
            rb_hash_aset(val, k, v);
        }
    }
}

/* put new Range object.(Range.new(low, high, flag)) */
insn
newrange(flag)(low, high)(val)
    rb_num_t flag;
    VALUE low, high, val;
{
    impl { val = rb_range_new(low, high, (int)flag); }
}

/**********************************************************/
/* deal with stack operation                              */
/**********************************************************/

/* pop from stack. */
insn
pop()(val)()
    VALUE val;
{
    impl {
        (void)val;
        /* none */
    }
}

/* duplicate stack top. */
insn
dup()(val)(val1, val2)
    VALUE val, val1, val2;
{
    impl { val1 = val2 = val; }
}

/* duplicate stack top n elements */
insn
dupn(n)(...)(...)
    rb_num_t n;
{
    attr rb_num_t sp_inc = { return n; };

    impl {
        rb_num_t i;
        VALUE *sp = STACK_ADDR_FROM_TOP(n);
        for (i = 0; i < n; i++) {
            GET_SP()[i] = sp[i];
        }
    }
}

/* swap top 2 vals */
insn
swap()(val, obj)(obj, val)
    VALUE val, obj;
{
    impl { /* none */ }
}

/* reverse stack top N order. */
insn
reverse(n)(...)(...)
    rb_num_t n;
{
    attr rb_num_t sp_inc = { return 0; };

    impl {
        rb_num_t i;
        VALUE *sp = STACK_ADDR_FROM_TOP(n);

        for (i=0; i<n/2; i++) {
            VALUE v0 = sp[i];
            VALUE v1 = TOPN(i);
            sp[i] = v1;
            TOPN(i) = v0;
        }
    }
}

/* for stack caching. */
insn
reput()(..., val)(val)
    VALUE val;
{
    attr rb_num_t sp_inc = { return 0; };

    impl { /* none */ }
}

/* get nth stack value from stack top */
insn
topn(n)(...)(val)
    rb_num_t n;
    VALUE val;
{
    attr rb_num_t sp_inc = { return 1; };

    impl { val = TOPN(n); }
}

/* set Nth stack entry to stack top */
insn
setn(n)(..., val)(val)
    rb_num_t n;
    VALUE val;
{
    attr rb_num_t sp_inc = { return 0; };

    impl { TOPN(n) = val; }
}

/* empty current stack */
insn
adjuststack(n)(...)(...)
    rb_num_t n;
{
    attr rb_num_t sp_inc = { return - n; };

    impl { /* none */ }
}

/**********************************************************/
/* deal with setting                                      */
/**********************************************************/

/* defined? */
insn
defined(op_type, obj, needstr)(v)(val)
    rb_num_t op_type;
    VALUE obj, needstr, v, val;
{
    impl { val = vm_defined(th, GET_CFP(), op_type, obj, needstr, v); }
}

/* check `target' matches `pattern'.
 *   `flag & VM_CHECKMATCH_TYPE_MASK' describe how to check pattern.
 *    VM_CHECKMATCH_TYPE_WHEN: ignore target and check pattern is truthy.
 *    VM_CHECKMATCH_TYPE_CASE: check `patten === target'.
 *    VM_CHECKMATCH_TYPE_RESCUE: check `pattern.kind_op?(Module) && pattern ==
 *       target'.
 *   if `flag & VM_CHECKMATCH_ARRAY' is not 0, then `patten' is array of
 *   patterns. */
insn
checkmatch(flag)(target, pattern)(result)
    rb_num_t flag;
    VALUE target, pattern, result;
{
    impl {
        enum vm_check_match_type checkmatch_type =
          (enum vm_check_match_type)(flag & VM_CHECKMATCH_TYPE_MASK);
        result = Qfalse;

        if (flag & VM_CHECKMATCH_ARRAY) {
            long i;
            for (i = 0; i < RARRAY_LEN(pattern); i++) {
                if (RTEST(check_match(RARRAY_AREF(pattern, i), target, checkmatch_type))) {
                    result = Qtrue;
                    break;
                }
            }
        }
        else {
            if (RTEST(check_match(pattern, target, checkmatch_type))) {
                result = Qtrue;
            }
        }
    }
}

/* check keywords are specified or not. */
insn
checkkeyword(kw_bits_index, keyword_index)()(ret)
    lindex_t kw_bits_index;
    rb_num_t keyword_index;
    VALUE ret;
{
    impl {
        const VALUE *ep = GET_EP();
        const VALUE kw_bits = *(ep - kw_bits_index);

        if (FIXNUM_P(kw_bits)) {
            int bits = FIX2INT(kw_bits);
            ret = (bits & (0x01 << keyword_index)) ? Qfalse : Qtrue;
        }
        else {
            VM_ASSERT(RB_TYPE_P(kw_bits, T_HASH));
            ret = rb_hash_has_key(kw_bits, INT2FIX(keyword_index)) ? Qfalse : Qtrue;
        }
    }
}

/* trace */
insn
trace(nf)()()
    rb_num_t nf;
{
    impl {
        rb_event_flag_t flag = (rb_event_flag_t)nf;

        if (RUBY_DTRACE_METHOD_ENTRY_ENABLED() ||
            RUBY_DTRACE_METHOD_RETURN_ENABLED() ||
            RUBY_DTRACE_CMETHOD_ENTRY_ENABLED() ||
            RUBY_DTRACE_CMETHOD_RETURN_ENABLED()) {

            switch (flag) {
              case RUBY_EVENT_CALL:
                RUBY_DTRACE_METHOD_ENTRY_HOOK(th, 0, 0);
                break;
              case RUBY_EVENT_C_CALL:
                RUBY_DTRACE_CMETHOD_ENTRY_HOOK(th, 0, 0);
                break;
              case RUBY_EVENT_RETURN:
                RUBY_DTRACE_METHOD_RETURN_HOOK(th, 0, 0);
                break;
              case RUBY_EVENT_C_RETURN:
                RUBY_DTRACE_CMETHOD_RETURN_HOOK(th, 0, 0);
                break;
            }
        }

        EXEC_EVENT_HOOK(th, flag, GET_SELF(), 0, 0, 0 /* id and klass are resolved at callee */,
                        (flag & (RUBY_EVENT_RETURN | RUBY_EVENT_B_RETURN)) ? TOPN(0) : Qundef);
    }
}

/**********************************************************/
/* deal with control flow 1: class/module                 */
/**********************************************************/

/*
 * enter class definition scope. if super is Qfalse, and class
 * "klass" is defined, it's redefine. otherwise, define "klass" class. */
insn
defineclass(id, class_iseq, flags)(cbase, super)(val)
    ID id;
    ISEQ class_iseq;
    rb_num_t flags;
    VALUE cbase, super, val;
{
    impl {
        VALUE klass;
        rb_vm_defineclass_type_t type = VM_DEFINECLASS_TYPE(flags);

        switch (type) {
          case VM_DEFINECLASS_TYPE_CLASS:
            /* val is dummy.  classdef returns class scope value */

            if (VM_DEFINECLASS_HAS_SUPERCLASS_P(flags) &&
                !RB_TYPE_P(super, T_CLASS)) {
                rb_raise(rb_eTypeError, "superclass must be a Class (%"PRIsVALUE" given)",
                         rb_obj_class(super));
            }

            vm_check_if_namespace(cbase);

            /* find klass */
            rb_autoload_load(cbase, id);
            if ((klass = vm_search_const_defined_class(cbase, id)) != 0) {
                /* already exist */
                klass = VM_DEFINECLASS_SCOPED_P(flags) ?
                    rb_public_const_get_at(klass, id) : rb_const_get_at(klass, id);
                if (!RB_TYPE_P(klass, T_CLASS)) {
                    rb_raise(rb_eTypeError, "%"PRIsVALUE" is not a class", rb_id2str(id));
                }

                if (VM_DEFINECLASS_HAS_SUPERCLASS_P(flags)) {
                    VALUE tmp;
                    tmp = rb_class_real(RCLASS_SUPER(klass));

                    if (tmp != super) {
                        rb_raise(rb_eTypeError, "superclass mismatch for class %"PRIsVALUE"",
                                 rb_id2str(id));
                    }
                }
            }
            else {
                if (!VM_DEFINECLASS_HAS_SUPERCLASS_P(flags)) {
                    super = rb_cObject;
                }
                /* new class declaration */
                klass = rb_define_class_id(id, super);
                rb_set_class_path_string(klass, cbase, rb_id2str(id));
                rb_const_set(cbase, id, klass);
                rb_class_inherited(super, klass);
            }
            break;
          case VM_DEFINECLASS_TYPE_SINGLETON_CLASS:
            /* val is dummy.  classdef returns class scope value */
            /* super is dummy */
            klass = rb_singleton_class(cbase);
            break;
          case VM_DEFINECLASS_TYPE_MODULE:
            /* val is dummy.  classdef returns class scope value */
            /* super is dummy */

            vm_check_if_namespace(cbase);

            /* find klass */
            if ((klass = vm_search_const_defined_class(cbase, id)) != 0) {
                klass = VM_DEFINECLASS_SCOPED_P(flags) ?
                    rb_public_const_get_at(klass, id) : rb_const_get_at(klass, id);
                /* already exist */
                if (!RB_TYPE_P(klass, T_MODULE)) {
                    rb_raise(rb_eTypeError, "%"PRIsVALUE" is not a module", rb_id2str(id));
                }
            }
            else {
                /* new module declaration */
                klass = rb_define_module_id(id);
                rb_set_class_path_string(klass, cbase, rb_id2str(id));
                rb_const_set(cbase, id, klass);
            }
            break;
          default:
            rb_bug("unknown defineclass type: %d", (int)type);
        }

        rb_iseq_check(class_iseq);

        /* enter scope */
        POPN(2); /* wipe out cbase, super */
        vm_push_frame(th, class_iseq, VM_FRAME_MAGIC_CLASS | VM_ENV_FLAG_LOCAL, klass,
                      GET_BLOCK_HANDLER(),
                      (VALUE)vm_cref_push(th, klass, NULL, FALSE),
                      class_iseq->body->iseq_encoded, GET_SP(),
                      class_iseq->body->local_table_size,
                      class_iseq->body->stack_max);
        RESTORE_REGS();
        NEXT_INSN();
    }
}

/**********************************************************/
/* deal with control flow 2: method/iterator              */
/**********************************************************/

/* invoke method. */
insn
send(ci, cc, blockiseq)(...)(val)
    CALL_INFO ci;
    CALL_CACHE cc;
    ISEQ blockiseq;
    VALUE val;
{
    attr rb_num_t sp_inc = {
        int yield_p = (ci->flag & VM_CALL_ARGS_BLOCKARG) ? 1 : 0;
        return - ci->orig_argc - yield_p;
    };

    impl {
        struct rb_calling_info calling;

        vm_caller_setup_arg_block(th, reg_cfp, &calling, ci, blockiseq, FALSE);
        vm_search_method(ci, cc, calling.recv = TOPN(calling.argc = ci->orig_argc));
        CALL_METHOD(&calling, ci, cc);
    }
}

insn
opt_str_freeze(str)()(val)
    VALUE str, val;
{
    impl {
        if (BASIC_OP_UNREDEFINED_P(BOP_FREEZE, STRING_REDEFINED_OP_FLAG)) {
            val = str;
        }
        else {
            val = rb_funcall(rb_str_resurrect(str), idFreeze, 0);
        }
    }
}

insn
opt_newarray_max(num)(...)(val)
    rb_num_t num;
    VALUE val;
{
    attr rb_num_t sp_inc = { return 1 - num; };

    impl {
#define id_cmp  idCmp
        if (BASIC_OP_UNREDEFINED_P(BOP_MAX, ARRAY_REDEFINED_OP_FLAG)) {
            if (num == 0) {
                val = Qnil;
            }
            else {
                struct cmp_opt_data cmp_opt = { 0, 0 };
                VALUE result = Qundef;
                rb_num_t i = num - 1;
                result = TOPN(i);
                while (i-- > 0) {
                    const VALUE v = TOPN(i);
                    if (result == Qundef || OPTIMIZED_CMP(v, result, cmp_opt) > 0) {
                        result = v;
                    }
                }
                val = result == Qundef ? Qnil : result;
            }
        }
        else {
            VALUE ary = rb_ary_new4((long)num, STACK_ADDR_FROM_TOP(num));
            val = rb_funcall(ary, idMax, 0);
        }
#undef id_cmp
    }
}

insn
opt_newarray_min(num)(...)(val)
    rb_num_t num;
    VALUE val;
{
    attr rb_num_t sp_inc = { return 1 - num; };

    impl {
#define id_cmp  idCmp
        if (BASIC_OP_UNREDEFINED_P(BOP_MIN, ARRAY_REDEFINED_OP_FLAG)) {
            if (num == 0) {
                val = Qnil;
            }
            else {
                struct cmp_opt_data cmp_opt = { 0, 0 };
                VALUE result = Qundef;
                rb_num_t i = num - 1;
                result = TOPN(i);
                while (i-- > 0) {
                    const VALUE v = TOPN(i);
                    if (result == Qundef || OPTIMIZED_CMP(v, result, cmp_opt) < 0) {
                        result = v;
                    }
                }
                val = result == Qundef ? Qnil : result;
            }
        }
        else {
            VALUE ary = rb_ary_new4((long)num, STACK_ADDR_FROM_TOP(num));
            val = rb_funcall(ary, idMin, 0);
        }
#undef id_cmp
    }
}

/* Invoke method without block */
insn
opt_send_without_block(ci, cc)(...)(val)
    CALL_INFO ci;
    CALL_CACHE cc;
    VALUE val;
{
    attr rb_num_t sp_inc = { return -ci->orig_argc; };

    impl {
        struct rb_calling_info calling;
        calling.block_handler = VM_BLOCK_HANDLER_NONE;
        vm_search_method(ci, cc, calling.recv = TOPN(calling.argc = ci->orig_argc));
        CALL_METHOD(&calling, ci, cc);
    }
}

/* super(args) # args.size => num */
insn
invokesuper(ci, cc, blockiseq)(...)(val)
    CALL_INFO ci;
    CALL_CACHE cc;
    ISEQ blockiseq;
    VALUE val;
{
    attr rb_num_t sp_inc = {
        int yield_p = (ci->flag & VM_CALL_ARGS_BLOCKARG) ? 1 : 0;
        return - ci->orig_argc - yield_p;
    };

    impl {
        struct rb_calling_info calling;
        calling.argc = ci->orig_argc;

        vm_caller_setup_arg_block(th, reg_cfp, &calling, ci, blockiseq, TRUE);
        calling.recv = GET_SELF();
        vm_search_super_method(th, GET_CFP(), &calling, ci, cc);
        CALL_METHOD(&calling, ci, cc);
    }
}

/* yield(args) */
insn
invokeblock(ci)(...)(val)
    CALL_INFO ci;
    VALUE val;
{
    attr rb_num_t sp_inc = { return 1 - ci->orig_argc; };

    impl {
        struct rb_calling_info calling;
        calling.argc = ci->orig_argc;
        calling.block_handler = VM_BLOCK_HANDLER_NONE;
        calling.recv = GET_SELF();

        val = vm_invoke_block(th, GET_CFP(), &calling, ci);
        if (val == Qundef) {
            RESTORE_REGS();
            NEXT_INSN();
        }
    }
}

/* return from this scope. */
insn
leave()(..., val)(val)
    VALUE val;
{
    attr rb_num_t sp_inc = {
        /* This instruction pops stack frame. */
        return 1;
    };

    impl {
        if (OPT_CHECKED_RUN) {
            const VALUE *const bp = vm_base_ptr(reg_cfp);
            if (reg_cfp->sp - 1 != bp) {
                rb_bug("Stack consistency error (sp: %"PRIdPTRDIFF", bp: %"PRIdPTRDIFF")",
                       VM_SP_CNT(th, reg_cfp->sp) - 1, VM_SP_CNT(th, bp));
            }
        }

        RUBY_VM_CHECK_INTS(th);

        if (vm_pop_frame(th, GET_CFP(), GET_EP())) {
#if OPT_CALL_THREADED_CODE
            th->retval = val;
            return 0;
#else
            return val;
#endif
        }
        else {
            RESTORE_REGS();
        }
    }
}

/**********************************************************/
/* deal with control flow 3: exception                    */
/**********************************************************/

/* longjump */
insn
throw(throw_state)(throwobj)(val)
    rb_num_t throw_state;
    VALUE throwobj, val;
{
    impl {
        RUBY_VM_CHECK_INTS(th);
        val = vm_throw(th, GET_CFP(), throw_state, throwobj);
        THROW_EXCEPTION(val);
        /* unreachable */
    }
}

/**********************************************************/
/* deal with control flow 4: local jump                   */
/**********************************************************/

/* set PC to (PC + dst). */
insn
jump(dst)()()
    OFFSET dst;
{
    impl {
        RUBY_VM_CHECK_INTS(th);
        JUMP(dst);
    }
}

/* if val is not false or nil, set PC to (PC + dst). */
insn
branchif(dst)(val)()
    OFFSET dst;
    VALUE val;
{
    impl {
        if (RTEST(val)) {
            RUBY_VM_CHECK_INTS(th);
            JUMP(dst);
        }
    }
}

/* if val is false or nil, set PC to (PC + dst). */
insn
branchunless(dst)(val)()
    OFFSET dst;
    VALUE val;
{
    impl {
        if (!RTEST(val)) {
            RUBY_VM_CHECK_INTS(th);
            JUMP(dst);
        }
    }
}

/* if val is nil, set PC to (PC + dst). */
insn
branchnil(dst)(val)()
    OFFSET dst;
    VALUE val;
{
    impl {
        if (NIL_P(val)) {
            RUBY_VM_CHECK_INTS(th);
            JUMP(dst);
        }
    }
}

/**********************************************************/
/* for optimize                                           */
/**********************************************************/

/* push inline-cached value and go to dst if it is valid */
insn
getinlinecache(dst, ic)()(val)
    OFFSET dst;
    IC ic;
    VALUE val;
{
    impl {
        if (ic->ic_serial == GET_GLOBAL_CONSTANT_STATE() &&
            (ic->ic_cref == NULL || ic->ic_cref == rb_vm_get_cref(GET_EP()))) {
            val = ic->ic_value.value;
            JUMP(dst);
        }
        else {
            /* none */
            val = Qnil;
        }
    }
}

/* set inline cache */
insn
setinlinecache(ic)(val)(val)
    IC ic;
    VALUE val;
{
    impl {
        VM_ASSERT(ic->ic_value.value != Qundef);
        ic->ic_value.value = val;
        ic->ic_serial = GET_GLOBAL_CONSTANT_STATE() - ruby_vm_const_missing_count;
        ic->ic_cref = vm_get_const_key_cref(GET_EP());
        ruby_vm_const_missing_count = 0;
    }
}

/* run iseq only once */
insn
once(iseq, ic)()(val)
    ISEQ iseq;
    IC ic;
    VALUE val;
{
    impl {
        union iseq_inline_storage_entry *is = (union iseq_inline_storage_entry *)ic;

#define RUNNING_THREAD_ONCE_DONE ((rb_thread_t *)(0x1))
      retry:
        if (is->once.running_thread == RUNNING_THREAD_ONCE_DONE) {
            val = is->once.value;
        }
        else if (is->once.running_thread == NULL) {
            is->once.running_thread = th;
            val = is->once.value = rb_ensure(vm_once_exec, (VALUE)iseq, vm_once_clear, (VALUE)is);
            /* is->once.running_thread is cleared by vm_once_clear() */
            is->once.running_thread = RUNNING_THREAD_ONCE_DONE; /* success */
            rb_iseq_add_mark_object(GET_ISEQ(), val);
        }
        else if (is->once.running_thread == th) {
            /* recursive once */
            val = vm_once_exec((VALUE)iseq);
        }
        else {
            /* waiting for finish */
            RUBY_VM_CHECK_INTS(th);
            rb_thread_schedule();
            goto retry;
        }
    }
}

/* case dispatcher, jump by table if possible */
insn
opt_case_dispatch(hash, else_offset)(..., key)()
    CDHASH hash;
    OFFSET else_offset;
    VALUE key;
{
    attr rb_num_t sp_inc = { return -1; };

    impl {
        switch (OBJ_BUILTIN_TYPE(key)) {
          case -1:
          case T_FLOAT:
          case T_SYMBOL:
          case T_BIGNUM:
          case T_STRING:
            if (BASIC_OP_UNREDEFINED_P(BOP_EQQ,
                                       SYMBOL_REDEFINED_OP_FLAG |
                                       INTEGER_REDEFINED_OP_FLAG |
                                       FLOAT_REDEFINED_OP_FLAG |
                                       NIL_REDEFINED_OP_FLAG    |
                                       TRUE_REDEFINED_OP_FLAG   |
                                       FALSE_REDEFINED_OP_FLAG  |
                                       STRING_REDEFINED_OP_FLAG)) {
                st_data_t val;
                if (RB_FLOAT_TYPE_P(key)) {
                    double kval = RFLOAT_VALUE(key);
                    if (!isinf(kval) && modf(kval, &kval) == 0.0) {
                        key = FIXABLE(kval) ? LONG2FIX((long)kval) : rb_dbl2big(kval);
                    }
                }
                if (st_lookup(RHASH_TBL_RAW(hash), key, &val)) {
                    JUMP(FIX2INT((VALUE)val));
                }
                else {
                    JUMP(else_offset);
                }
            }
        }
    }
}

/** simple functions */

/* optimized X+Y. */
insn
opt_plus(ci, cc)(recv, obj)(val)
    CALL_INFO ci;
    CALL_CACHE cc;
    VALUE recv, obj, val;
{
    impl {
        if (FIXNUM_2_P(recv, obj) &&
            BASIC_OP_UNREDEFINED_P(BOP_PLUS,INTEGER_REDEFINED_OP_FLAG)) {
            /* fixnum + fixnum */
#ifndef LONG_LONG_VALUE
            VALUE msb = (VALUE)1 << ((sizeof(VALUE) * CHAR_BIT) - 1);
            val = recv - 1 + obj;
            if ((~(recv ^ obj) & (recv ^ val)) & msb) {
                val = rb_int2big((SIGNED_VALUE)((val>>1) | (recv & msb)));
            }
#else
            val = LONG2NUM(FIX2LONG(recv) + FIX2LONG(obj));
#endif
        }
        else if (FLONUM_2_P(recv, obj) &&
                 BASIC_OP_UNREDEFINED_P(BOP_PLUS, FLOAT_REDEFINED_OP_FLAG)) {
            val = DBL2NUM(RFLOAT_VALUE(recv) + RFLOAT_VALUE(obj));
        }
        else if (!SPECIAL_CONST_P(recv) && !SPECIAL_CONST_P(obj)) {
            if (RBASIC_CLASS(recv) == rb_cFloat && RBASIC_CLASS(obj) == rb_cFloat &&
                BASIC_OP_UNREDEFINED_P(BOP_PLUS, FLOAT_REDEFINED_OP_FLAG)) {
                val = DBL2NUM(RFLOAT_VALUE(recv) + RFLOAT_VALUE(obj));
            }
            else if (RBASIC_CLASS(recv) == rb_cString && RBASIC_CLASS(obj) == rb_cString &&
                     BASIC_OP_UNREDEFINED_P(BOP_PLUS, STRING_REDEFINED_OP_FLAG)) {
                val = rb_str_plus(recv, obj);
            }
            else if (RBASIC_CLASS(recv) == rb_cArray &&
                     BASIC_OP_UNREDEFINED_P(BOP_PLUS, ARRAY_REDEFINED_OP_FLAG)) {
                val = rb_ary_plus(recv, obj);
            }
            else {
                goto INSN_LABEL(normal_dispatch);
            }
        }
        else {
            INSN_LABEL(normal_dispatch):
            CALL_SIMPLE_METHOD(recv);
        }
    }
}

/* optimized X-Y. */
insn
opt_minus(ci, cc)(recv, obj)(val)
    CALL_INFO ci;
    CALL_CACHE cc;
    VALUE recv, obj, val;
{
    impl {
        if (FIXNUM_2_P(recv, obj) &&
            BASIC_OP_UNREDEFINED_P(BOP_MINUS, INTEGER_REDEFINED_OP_FLAG)) {
            long a, b, c;

            a = FIX2LONG(recv);
            b = FIX2LONG(obj);
            c = a - b;
            val = LONG2NUM(c);
        }
        else if (FLONUM_2_P(recv, obj) &&
                 BASIC_OP_UNREDEFINED_P(BOP_MINUS, FLOAT_REDEFINED_OP_FLAG)) {
            val = DBL2NUM(RFLOAT_VALUE(recv) - RFLOAT_VALUE(obj));
        }
        else if (!SPECIAL_CONST_P(recv) && !SPECIAL_CONST_P(obj)) {
            if (RBASIC_CLASS(recv) == rb_cFloat && RBASIC_CLASS(obj) == rb_cFloat  &&
                BASIC_OP_UNREDEFINED_P(BOP_MINUS, FLOAT_REDEFINED_OP_FLAG)) {
                val = DBL2NUM(RFLOAT_VALUE(recv) - RFLOAT_VALUE(obj));
            }
            else {
                goto INSN_LABEL(normal_dispatch);
            }
        }
        else {
            /* other */
          INSN_LABEL(normal_dispatch):
            CALL_SIMPLE_METHOD(recv);
        }
    }
}

/* optimized X*Y. */
insn
opt_mult(ci, cc)(recv, obj)(val)
    CALL_INFO ci;
    CALL_CACHE cc;
    VALUE recv, obj, val;
{
    impl {
        if (FIXNUM_2_P(recv, obj) &&
            BASIC_OP_UNREDEFINED_P(BOP_MULT, INTEGER_REDEFINED_OP_FLAG)) {
            val = rb_fix_mul_fix(recv, obj);
        }
        else if (FLONUM_2_P(recv, obj) &&
                 BASIC_OP_UNREDEFINED_P(BOP_MULT, FLOAT_REDEFINED_OP_FLAG)) {
            val = DBL2NUM(RFLOAT_VALUE(recv) * RFLOAT_VALUE(obj));
        }
        else if (!SPECIAL_CONST_P(recv) && !SPECIAL_CONST_P(obj)) {
            if (RBASIC_CLASS(recv) == rb_cFloat && RBASIC_CLASS(obj) == rb_cFloat  &&
                BASIC_OP_UNREDEFINED_P(BOP_MULT, FLOAT_REDEFINED_OP_FLAG)) {
                val = DBL2NUM(RFLOAT_VALUE(recv) * RFLOAT_VALUE(obj));
            }
            else {
                goto INSN_LABEL(normal_dispatch);
            }
        }
        else {
          INSN_LABEL(normal_dispatch):
            CALL_SIMPLE_METHOD(recv);
        }
    }
}

/* optimized X/Y. */
insn
opt_div(ci, cc)(recv, obj)(val)
    CALL_INFO ci;
    CALL_CACHE cc;
    VALUE recv, obj, val;
{
    impl {
        if (FIXNUM_2_P(recv, obj) &&
            BASIC_OP_UNREDEFINED_P(BOP_DIV, INTEGER_REDEFINED_OP_FLAG)) {
            if (FIX2LONG(obj) == 0) goto INSN_LABEL(normal_dispatch);
            val = rb_fix_div_fix(recv, obj);
        }
        else if (FLONUM_2_P(recv, obj) &&
                 BASIC_OP_UNREDEFINED_P(BOP_DIV, FLOAT_REDEFINED_OP_FLAG)) {
            val = DBL2NUM(RFLOAT_VALUE(recv) / RFLOAT_VALUE(obj));
        }
        else if (!SPECIAL_CONST_P(recv) && !SPECIAL_CONST_P(obj)) {
            if (RBASIC_CLASS(recv) == rb_cFloat && RBASIC_CLASS(obj) == rb_cFloat  &&
                BASIC_OP_UNREDEFINED_P(BOP_DIV, FLOAT_REDEFINED_OP_FLAG)) {
                val = DBL2NUM(RFLOAT_VALUE(recv) / RFLOAT_VALUE(obj));
            }
            else {
                goto INSN_LABEL(normal_dispatch);
            }
        }
        else {
          INSN_LABEL(normal_dispatch):
            CALL_SIMPLE_METHOD(recv);
        }
    }
}

/* optimized X%Y. */
insn
opt_mod(ci, cc)(recv, obj)(val)
    CALL_INFO ci;
    CALL_CACHE cc;
    VALUE recv, obj, val;
{
    impl {
        if (FIXNUM_2_P(recv, obj) &&
            BASIC_OP_UNREDEFINED_P(BOP_MOD, INTEGER_REDEFINED_OP_FLAG )) {
            if (FIX2LONG(obj) == 0) goto INSN_LABEL(normal_dispatch);
            val = rb_fix_mod_fix(recv, obj);
        }
        else if (FLONUM_2_P(recv, obj) &&
                 BASIC_OP_UNREDEFINED_P(BOP_MOD, FLOAT_REDEFINED_OP_FLAG)) {
            val = DBL2NUM(ruby_float_mod(RFLOAT_VALUE(recv), RFLOAT_VALUE(obj)));
        }
        else if (!SPECIAL_CONST_P(recv) && !SPECIAL_CONST_P(obj)) {
            if (RBASIC_CLASS(recv) == rb_cFloat && RBASIC_CLASS(obj) == rb_cFloat &&
                BASIC_OP_UNREDEFINED_P(BOP_MOD, FLOAT_REDEFINED_OP_FLAG)) {
                val = DBL2NUM(ruby_float_mod(RFLOAT_VALUE(recv), RFLOAT_VALUE(obj)));
            }
            else {
                goto INSN_LABEL(normal_dispatch);
            }
        }
        else {
          INSN_LABEL(normal_dispatch):
            CALL_SIMPLE_METHOD(recv);
        }
    }
}

/* optimized X==Y. */
insn
opt_eq(ci, cc)(recv, obj)(val)
    CALL_INFO ci;
    CALL_CACHE cc;
    VALUE recv, obj, val;
{
    impl {
        val = opt_eq_func(recv, obj, ci, cc);

        if (val == Qundef) {
            /* other */
            CALL_SIMPLE_METHOD(recv);
        }
    }
}

/* optimized X!=Y. */
insn
opt_neq(ci, cc, ci_eq, cc_eq)(recv, obj)(val)
    CALL_INFO ci, ci_eq;
    CALL_CACHE cc, cc_eq;
    VALUE recv, obj, val;
{
    impl {
        extern VALUE rb_obj_not_equal(VALUE obj1, VALUE obj2);
        vm_search_method(ci, cc, recv);

        val = Qundef;

        if (check_cfunc(cc->me, rb_obj_not_equal)) {
            val = opt_eq_func(recv, obj, ci_eq, cc_eq);

            if (val != Qundef) {
                val = RTEST(val) ? Qfalse : Qtrue;
            }
        }

        if (val == Qundef) {
            /* other */
            CALL_SIMPLE_METHOD(recv);
        }
    }
}

/* optimized X<Y. */
insn
opt_lt(ci, cc)(recv, obj)(val)
    CALL_INFO ci;
    CALL_CACHE cc;
    VALUE recv, obj, val;
{
    impl {
        if (FIXNUM_2_P(recv, obj) &&
            BASIC_OP_UNREDEFINED_P(BOP_LT, INTEGER_REDEFINED_OP_FLAG)) {
            SIGNED_VALUE a = recv, b = obj;

            if (a < b) {
                val = Qtrue;
            }
            else {
                val = Qfalse;
            }
        }
        else if (FLONUM_2_P(recv, obj) &&
                 BASIC_OP_UNREDEFINED_P(BOP_LT, FLOAT_REDEFINED_OP_FLAG)) {
            /* flonum is not NaN */
            val = RFLOAT_VALUE(recv) < RFLOAT_VALUE(obj) ? Qtrue : Qfalse;
        }
        else if (FLOAT_INSTANCE_P(recv) && FLOAT_INSTANCE_P(obj) &&
                 BASIC_OP_UNREDEFINED_P(BOP_LT, FLOAT_REDEFINED_OP_FLAG)) {
            val = double_cmp_lt(RFLOAT_VALUE(recv), RFLOAT_VALUE(obj));
        }
        else {
            CALL_SIMPLE_METHOD(recv);
        }
    }
}

/* optimized X<=Y. */
insn
opt_le(ci, cc)(recv, obj)(val)
    CALL_INFO ci;
    CALL_CACHE cc;
    VALUE recv, obj, val;
{
    impl {
        if (FIXNUM_2_P(recv, obj) &&
            BASIC_OP_UNREDEFINED_P(BOP_LE, INTEGER_REDEFINED_OP_FLAG)) {
            SIGNED_VALUE a = recv, b = obj;

            if (a <= b) {
                val = Qtrue;
            }
            else {
                val = Qfalse;
            }
        }
        else if (FLONUM_2_P(recv, obj) &&
                 BASIC_OP_UNREDEFINED_P(BOP_LE, FLOAT_REDEFINED_OP_FLAG)) {
            /* flonum is not NaN */
            val = RFLOAT_VALUE(recv) <= RFLOAT_VALUE(obj) ? Qtrue : Qfalse;
        }
        else if (FLOAT_INSTANCE_P(recv) && FLOAT_INSTANCE_P(obj) &&
                 BASIC_OP_UNREDEFINED_P(BOP_LT, FLOAT_REDEFINED_OP_FLAG)) {
            val = double_cmp_le(RFLOAT_VALUE(recv), RFLOAT_VALUE(obj));
        }
        else {
            /* other */
            CALL_SIMPLE_METHOD(recv);
        }
    }
}

/* optimized X>Y. */
insn
opt_gt(ci, cc)(recv, obj)(val)
    CALL_INFO ci;
    CALL_CACHE cc;
    VALUE recv, obj, val;
{
    impl {
        if (FIXNUM_2_P(recv, obj) &&
            BASIC_OP_UNREDEFINED_P(BOP_GT, INTEGER_REDEFINED_OP_FLAG)) {
            SIGNED_VALUE a = recv, b = obj;

            if (a > b) {
                val = Qtrue;
            }
            else {
                val = Qfalse;
            }
        }
        else if (FLONUM_2_P(recv, obj) &&
                 BASIC_OP_UNREDEFINED_P(BOP_GT, FLOAT_REDEFINED_OP_FLAG)) {
            /* flonum is not NaN */
            val = RFLOAT_VALUE(recv) > RFLOAT_VALUE(obj) ? Qtrue : Qfalse;
        }
        else if (FLOAT_INSTANCE_P(recv) && FLOAT_INSTANCE_P(obj) &&
                 BASIC_OP_UNREDEFINED_P(BOP_LT, FLOAT_REDEFINED_OP_FLAG)) {
            val = double_cmp_gt(RFLOAT_VALUE(recv), RFLOAT_VALUE(obj));
        }
        else {
            CALL_SIMPLE_METHOD(recv);
        }
    }
}

/* optimized X>=Y. */
insn
opt_ge(ci, cc)(recv, obj)(val)
    CALL_INFO ci;
    CALL_CACHE cc;
    VALUE recv, obj, val;
{
    impl {
        if (FIXNUM_2_P(recv, obj) &&
            BASIC_OP_UNREDEFINED_P(BOP_GE, INTEGER_REDEFINED_OP_FLAG)) {
            SIGNED_VALUE a = recv, b = obj;

            if (a >= b) {
                val = Qtrue;
            }
            else {
                val = Qfalse;
            }
        }
        else if (FLONUM_2_P(recv, obj) &&
                 BASIC_OP_UNREDEFINED_P(BOP_GE, FLOAT_REDEFINED_OP_FLAG)) {
            /* flonum is not NaN */
            val = RFLOAT_VALUE(recv) >= RFLOAT_VALUE(obj) ? Qtrue : Qfalse;
        }
        else if (FLOAT_INSTANCE_P(recv) && FLOAT_INSTANCE_P(obj) &&
                 BASIC_OP_UNREDEFINED_P(BOP_LT, FLOAT_REDEFINED_OP_FLAG)) {
            val = double_cmp_ge(RFLOAT_VALUE(recv), RFLOAT_VALUE(obj));
        }
        else {
            CALL_SIMPLE_METHOD(recv);
        }
    }
}

/* << */
insn
opt_ltlt(ci, cc)(recv, obj)(val)
    CALL_INFO ci;
    CALL_CACHE cc;
    VALUE recv, obj, val;
{
    impl {
        if (!SPECIAL_CONST_P(recv)) {
            if (RBASIC_CLASS(recv) == rb_cString &&
                BASIC_OP_UNREDEFINED_P(BOP_LTLT, STRING_REDEFINED_OP_FLAG)) {
                val = rb_str_concat(recv, obj);
            }
            else if (RBASIC_CLASS(recv) == rb_cArray &&
                     BASIC_OP_UNREDEFINED_P(BOP_LTLT, ARRAY_REDEFINED_OP_FLAG)) {
                val = rb_ary_push(recv, obj);
            }
            else {
                goto INSN_LABEL(normal_dispatch);
            }
        }
        else {
          INSN_LABEL(normal_dispatch):
            CALL_SIMPLE_METHOD(recv);
        }
    }
}

/* [] */
insn
opt_aref(ci, cc)(recv, obj)(val)
    CALL_INFO ci;
    CALL_CACHE cc;
    VALUE recv, obj, val;
{
    impl {
        if (!SPECIAL_CONST_P(recv)) {
            if (RBASIC_CLASS(recv) == rb_cArray && BASIC_OP_UNREDEFINED_P(BOP_AREF, ARRAY_REDEFINED_OP_FLAG) && FIXNUM_P(obj)) {
                val = rb_ary_entry(recv, FIX2LONG(obj));
            }
            else if (RBASIC_CLASS(recv) == rb_cHash && BASIC_OP_UNREDEFINED_P(BOP_AREF, HASH_REDEFINED_OP_FLAG)) {
                val = rb_hash_aref(recv, obj);
            }
            else {
                goto INSN_LABEL(normal_dispatch);
            }
        }
        else {
          INSN_LABEL(normal_dispatch):
            CALL_SIMPLE_METHOD(recv);
        }
    }
}

/* recv[obj] = set */
insn
opt_aset(ci, cc)(recv, obj, set)(val)
    CALL_INFO ci;
    CALL_CACHE cc;
    VALUE recv, obj, set, val;
{
    impl {
        if (!SPECIAL_CONST_P(recv)) {
            if (RBASIC_CLASS(recv) == rb_cArray && BASIC_OP_UNREDEFINED_P(BOP_ASET, ARRAY_REDEFINED_OP_FLAG) && FIXNUM_P(obj)) {
                rb_ary_store(recv, FIX2LONG(obj), set);
                val = set;
            }
            else if (RBASIC_CLASS(recv) == rb_cHash && BASIC_OP_UNREDEFINED_P(BOP_ASET, HASH_REDEFINED_OP_FLAG)) {
                rb_hash_aset(recv, obj, set);
                val = set;
            }
            else {
                goto INSN_LABEL(normal_dispatch);
            }
        }
        else {
          INSN_LABEL(normal_dispatch):
            CALL_SIMPLE_METHOD(recv);
        }
    }
}

/* recv[str] = set */
insn
opt_aset_with(ci, cc, key)(recv, val)(val)
    CALL_INFO ci;
    CALL_CACHE cc;
    VALUE key, recv, val;
{
    impl {
        if (!SPECIAL_CONST_P(recv) && RBASIC_CLASS(recv) == rb_cHash &&
            BASIC_OP_UNREDEFINED_P(BOP_ASET, HASH_REDEFINED_OP_FLAG) &&
            rb_hash_compare_by_id_p(recv) == Qfalse) {
            rb_hash_aset(recv, key, val);
        }
        else {
            TOPN(0) = rb_str_resurrect(key);
            PUSH(val);
            CALL_SIMPLE_METHOD(recv);
        }
    }
}

/* recv[str] */
insn
opt_aref_with(ci, cc, key)(recv)(val)
    CALL_INFO ci;
    CALL_CACHE cc;
    VALUE key, recv, val;
{
    impl {
        if (!SPECIAL_CONST_P(recv) && RBASIC_CLASS(recv) == rb_cHash &&
            BASIC_OP_UNREDEFINED_P(BOP_AREF, HASH_REDEFINED_OP_FLAG) &&
            rb_hash_compare_by_id_p(recv) == Qfalse) {
            val = rb_hash_aref(recv, key);
        }
        else {
            PUSH(rb_str_resurrect(key));
            CALL_SIMPLE_METHOD(recv);
        }
    }
}

/* optimized length */
insn
opt_length(ci, cc)(recv)(val)
    CALL_INFO ci;
    CALL_CACHE cc;
    VALUE recv, val;
{
    impl {
        if (!SPECIAL_CONST_P(recv)) {
            if (RBASIC_CLASS(recv) == rb_cString &&
                BASIC_OP_UNREDEFINED_P(BOP_LENGTH, STRING_REDEFINED_OP_FLAG)) {
                val = rb_str_length(recv);
            }
            else if (RBASIC_CLASS(recv) == rb_cArray &&
                     BASIC_OP_UNREDEFINED_P(BOP_LENGTH, ARRAY_REDEFINED_OP_FLAG)) {
                val = LONG2NUM(RARRAY_LEN(recv));
            }
            else if (RBASIC_CLASS(recv) == rb_cHash &&
                     BASIC_OP_UNREDEFINED_P(BOP_LENGTH, HASH_REDEFINED_OP_FLAG)) {
                val = INT2FIX(RHASH_SIZE(recv));
            }
            else {
                goto INSN_LABEL(normal_dispatch);
            }
        }
        else {
          INSN_LABEL(normal_dispatch):
            CALL_SIMPLE_METHOD(recv);
        }
    }
}

/* optimized size */
insn
opt_size(ci, cc)(recv)(val)
    CALL_INFO ci;
    CALL_CACHE cc;
    VALUE recv, val;
{
    impl {
        if (!SPECIAL_CONST_P(recv)) {
            if (RBASIC_CLASS(recv) == rb_cString &&
                BASIC_OP_UNREDEFINED_P(BOP_SIZE, STRING_REDEFINED_OP_FLAG)) {
                val = rb_str_length(recv);
            }
            else if (RBASIC_CLASS(recv) == rb_cArray &&
                     BASIC_OP_UNREDEFINED_P(BOP_SIZE, ARRAY_REDEFINED_OP_FLAG)) {
                val = LONG2NUM(RARRAY_LEN(recv));
            }
            else if (RBASIC_CLASS(recv) == rb_cHash &&
                     BASIC_OP_UNREDEFINED_P(BOP_SIZE, HASH_REDEFINED_OP_FLAG)) {
                val = INT2FIX(RHASH_SIZE(recv));
            }
            else {
                goto INSN_LABEL(normal_dispatch);
            }
        }
        else {
          INSN_LABEL(normal_dispatch):
            CALL_SIMPLE_METHOD(recv);
        }
    }
}

/* optimized empty? */
insn
opt_empty_p(ci, cc)(recv)(val)
    CALL_INFO ci;
    CALL_CACHE cc;
    VALUE recv, val;
{
    impl {
        if (!SPECIAL_CONST_P(recv)) {
            if (RBASIC_CLASS(recv) == rb_cString &&
                BASIC_OP_UNREDEFINED_P(BOP_EMPTY_P, STRING_REDEFINED_OP_FLAG)) {
                if (RSTRING_LEN(recv) == 0) val = Qtrue;
                else val = Qfalse;
            }
            else if (RBASIC_CLASS(recv) == rb_cArray &&
                     BASIC_OP_UNREDEFINED_P(BOP_EMPTY_P, ARRAY_REDEFINED_OP_FLAG)) {
                if (RARRAY_LEN(recv) == 0) val = Qtrue;
                else val = Qfalse;
            }
            else if (RBASIC_CLASS(recv) == rb_cHash &&
                     BASIC_OP_UNREDEFINED_P(BOP_EMPTY_P, HASH_REDEFINED_OP_FLAG)) {
                if (RHASH_EMPTY_P(recv)) val = Qtrue;
                else val = Qfalse;
            }
            else {
                goto INSN_LABEL(normal_dispatch);
            }
        }
        else {
          INSN_LABEL(normal_dispatch):
            CALL_SIMPLE_METHOD(recv);
        }
    }
}

/* optimized succ */
insn
opt_succ(ci, cc)(recv)(val)
    CALL_INFO ci;
    CALL_CACHE cc;
    VALUE recv, val;
{
    impl {
        if (SPECIAL_CONST_P(recv)) {
            if (FIXNUM_P(recv) &&
                BASIC_OP_UNREDEFINED_P(BOP_SUCC, INTEGER_REDEFINED_OP_FLAG)) {
                /* fixnum + INT2FIX(1) */
                if (recv != LONG2FIX(FIXNUM_MAX)) {
                    val = recv - 1 + INT2FIX(1);
                }
                else {
                    val = LONG2NUM(FIXNUM_MAX + 1);
                }
            }
            else {
                goto INSN_LABEL(normal_dispatch);
            }
        }
        else {
            if (RBASIC_CLASS(recv) == rb_cString &&
                BASIC_OP_UNREDEFINED_P(BOP_SUCC, STRING_REDEFINED_OP_FLAG)) {
                val = rb_str_succ(recv);
            }
            else {
                goto INSN_LABEL(normal_dispatch);
            }
        }
        if (0) {
          INSN_LABEL(normal_dispatch):
            CALL_SIMPLE_METHOD(recv);
        }
    }
}

/* optimized not */
insn
opt_not(ci, cc)(recv)(val)
    CALL_INFO ci;
    CALL_CACHE cc;
    VALUE recv, val;
{
    impl {
        vm_search_method(ci, cc, recv);

        if (check_cfunc(cc->me, rb_obj_not)) {
            val = RTEST(recv) ? Qfalse : Qtrue;
        }
        else {
            CALL_SIMPLE_METHOD(recv);
        }
    }
}

/* optimized regexp match */
insn
opt_regexpmatch1(r)(obj)(val)
    VALUE r, obj, val;
{
    impl {
        if (BASIC_OP_UNREDEFINED_P(BOP_MATCH, REGEXP_REDEFINED_OP_FLAG)) {
            val = rb_reg_match(r, obj);
        }
        else {
            val = rb_funcall(r, idEqTilde, 1, obj);
        }
    }
}

/* optimized regexp match 2 */
insn
opt_regexpmatch2(ci, cc)(obj2, obj1)(val)
    CALL_INFO ci;
    CALL_CACHE cc;
    VALUE obj2, obj1, val;
{
    impl {
        if (CLASS_OF(obj2) == rb_cString &&
            BASIC_OP_UNREDEFINED_P(BOP_MATCH, STRING_REDEFINED_OP_FLAG)) {
            val = rb_reg_match(obj1, obj2);
        }
        else {
            CALL_SIMPLE_METHOD(obj2);
        }
    }
}

/* call native compiled method */
insn
opt_call_c_function(funcptr)()()
    rb_insn_func_t funcptr;
{
    impl {
        reg_cfp = (funcptr)(th, reg_cfp);

        if (reg_cfp == 0) {
            VALUE err = th->errinfo;
            th->errinfo = Qnil;
            THROW_EXCEPTION(err);
        }

        RESTORE_REGS();
        NEXT_INSN();
    }
}

/* BLT */
insn
bitblt()()(ret)
    VALUE ret;
{
    impl { ret = rb_str_new2("a bit of bacon, lettuce and tomato"); }
}

/* The Answer to Life, the Universe, and Everything */
insn
answer()()(ret)
    VALUE ret;
{
    impl { ret = INT2FIX(42); }
}

